## NextJS - V14

### Old vs New

- 올드버전은 pages로 router 세팅
- 새로운건 app을 활용해서 새로운 방법
- 하지만 둘다 사용해도 상관없으니 무리해서 바꿀필욘 X
- 새로운 신기능을 이제 app에서도 사용할 수 있다.

### 수동세팅

```react
// 수동으로 해보는 초기설정
1. npm init -y
2. JSON script license -> MIT
3. npm install react@latest next@latest react-dom@latest
4. app 폴더에 page.tsx or page.jsx 만들고
5. npm run dev 해보기 // 여기서 타입스크립트 tsx면 자동설치해줌

```

### useCallback

```react
  // 불필요한 렌더링을 방지하기 위해서인데 컴포넌트에 속성으로 들어가는 함수는 useCallback으로 감싸주는것이 좋다
  const onIncrement = useCallback(() => dispatch(increment()), []);
  const onDecrement = useCallback(() => dispatch(decrement()), []);
  // redux-thunk
  const onReduxThunk = useCallback(() => dispatch(fetchAsync("갔냐?")), []);
// 아래 버튼에 달린 함수들
  <button className="w-10 text-2xl border-2" onClick={onIncrement}>
    +
  </button>
  <button className="w-10 text-2xl border-2" onClick={onDecrement}>
    -
  </button>
  <button className="w-10 text-2xl border-2" onClick={onReduxThunk}>
    X
  </button>
```

## Routing

### Routes

![image-20240208234505093](C:\Users\han\Desktop\NextJS\nextjs-practice\nextjs-v14-practice\assets\image-20240208234505093.png)

- url명은 폴더를 만듦으로써 생성할 수 있다.
- 다만 안에 page.tsx가 없으면 url이 아니라 일반 컴포넌트로 쓸수 있음
- 스샷처럼 components란 폴더안에 page.tsx파일을 만들지 않았기에 일반 컴포넌트로 쓸 수 있음
- 사용자가 url로 보게되는 페이지는 page.tsx임 (이전 버전의 index.tsx와 용도가 같음)
- URL에 영향을 주지 않고 경로를 구성하려면 관련 경로를 함께 유지하는 그룹을 만드세요. 괄호 안의 폴더는 URL에서 생략됩니다(예: `(marketing)`또는 `(shop)`).

### Not Found

- app폴더 안에 not-found.tsx 이름으로 만들어야함

### usePathname

![image-20240213144336881](C:\Users\han\Desktop\NextJS\nextjs-practice\nextjs-v14-practice\assets\image-20240213144336881.png)

- 이런 에러 발생 해결을 위해 가장 윗 줄에 'use client' 추가
- 왜 이런일이 일어나는지 다음거에 봐보자

## CSR vs SSR

- 순수 react만으로 하면 CSR인데 유저가 딱 도착했을때는 빈페이지뿐
- 브라우저가 자바스크립트 파일을 다운받고 난 후에야 렌더링됨
- 아무래도 첫 로딩이 좀 길수밖에 없다
- 그리고 검색엔진이 빈페이지를 볼수밖에 없음 자바스크립트를 실행시키지 않으니까

### NextJS

- NextJs로 빌드하면 자동으로 Default가 SSR이다
- 이미 완성된 html페이지기 때문에 자바스크립트가 활성화 되어있지 않아도 볼 수가 있다
- 사용자가 접근을 하면 어떠한 HTML을 주기 전에 next.js 는 server 즉 backend에서 application을 render 한다.
- !! use client를 썻지만 client단에서 렌더링 되는게아니라 server에서 렌더링되는 SSR시스템을 따른다. 이름 헷갈리니 주의
- 모든 컴포넌트와 페이지는 server, 즉 backend에서 렌더링된다!

** render란 javascript function을 가져와서 브라우저가 이해할 수 있는 HTML로 변환하는 작업

### Hydration

- Next.js는 초기 Html 파일을 먼저 전달하고 이후 HTML 요소들을 React 컴포넌트로 변환 및 이벤트리스너를 부착하여 React DOM에서 관리하게 한다. 이 과정을 Hydration(수분 보충)이라고 한다!!

- 처음에 SSR렌더링 이후 이제 react가 끼어듬
- 만약 JavaScript를 끄면 네이게이션 이동시 a anchor라서 페이지 전체 재렌더링이 일어나지만 JavaScript를 켜면 이제 전체 재렌더링이 아닌 바뀌는 부분만 바뀌는 Link를 이용한 React를 Component 사용
- 이 Link Component는 CSR이다
- 즉, 첫 페이지는 SSR로 Html 던져주고 후에 프레임워크가 load를 시작해서 CSR React App으로 바뀌는 느낌

![image-20240213160038895](C:\Users\han\Desktop\NextJS\nextjs-practice\nextjs-v14-practice\assets\image-20240213160038895.png)

![image-20240213160410036](C:\Users\han\Desktop\NextJS\nextjs-practice\nextjs-v14-practice\assets\image-20240213160410036.png)

- 이렇게 처음에는 그냥 0인 버튼을 렌더링해줘서 클릭해도 아무런 이벤트가 발생하지 않지만 후에 JavaScript가 로드되고 React Component가 된다면 onClick 이벤트가 연결된 버튼으로 바뀐다

!! 하지만 Hydrate되는 component는 맨위에 "use client"가 적힌 component들 뿐이다!! 이렇게 해야 다운받는 JavaScript양이 적어지고 최적화 및 성능에 좋다

!! "use client"가 적혀있지 않은 component들은 기본적으로 모두 server component다!

- server component안에는 client component가 가능하지만
- client component안에는 server component를 가질 수 없다 자동으로 client component가 된다. 즉 모든 children이 client component임
- 그런데 지금은 client component 안에 server component도 가능하지만 prop를 통해 전달해야 한다고함
- https://nextjs.org/docs/app/building-your-application/rendering/composition-patterns#supported-pattern-passing-server-components-to-client-components-as-props

## Layout

```react
import Navigation from "../components/navigation";

export const metadata = {
  title: "Next.js",
  description: "Generated by Next.js",
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en">
      <body>
        <Navigation />
        {children}
      </body>
    </html>
  );
}
// 기본적인건 이렇게 레이아웃이 가장 처음에 렌더링되기 때문에 쓰면된다
```

```react
export default function AboutUsLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <div>
      {children}
      &copy; Next Js 14
    </div>
  );
}
// 폴더안에 새로운 layout 파일을 만들면 이제 그 url로 이동할때만 생기는 layout이 나타난다
// 다만 상위폴더부터 layout이 "중첩"되어 나타남!
```

![image-20240213165244204](C:\Users\han\Desktop\NextJS\nextjs-practice\nextjs-v14-practice\assets\image-20240213165244204.png)

- 이런식으로 상위폴더부터 중첩된다

- 서로 상쇄나 대체가아닌 "중첩"이다

  

### Metadata & Group Routes

- 페이지에서 rootLayout을 제외하고싶으면 폴더이름을 괄호로 묶어서 그룹으로 묶어서 여러 레이아웃을 만드는 방법이있다
- https://stackoverflow.com/questions/76251099/exclude-a-page-from-the-next-js-root-layout-in-the-app-folder

```react
export const metadata = {
  title: "Next.js",
  description: "Generated by Next.js",
};

// 메타 데이터이다. 이걸 layout이 아닌 각 페이지로 옮겨서 쓸 수 있다 다른제목 다른설명으로
// 메타 데이터는 중첩이아닌 병합이 된다
// ** 메타 데이터는 "페이지", "레이아웃" 에서만 가능하고 server component에서만 있을 수 있다
// 하지만 이제 페이지마다 만드는건 비효율적이니까 layout에 이제 하나로 만들어보자

export const metadata: Metadata = {
  title: { default: "...Loading", template: "%s | NextJS-14" },
  description: "Generated by Next.js",
};
// 이런식으로 할 수 있음 그러면 이제 페이지별로
export const metadata: Metadata = {
  title: "About-Us",
};
// 이렇게 타이틀을 하면 template의 %s 부분에 들어감
// 처음 layout의 root부분의 default값은 이제 metadata 설정을 안한 페이지에 가면 저렇게 ...Loading 이 뜸

```

![image-20240213172854249](C:\Users\han\Desktop\NextJS\nextjs-practice\nextjs-v14-practice\assets\image-20240213172854249.png)

- 공식문서에 다양하게 많은 것들이 있다
- https://nextjs.org/docs/app/building-your-application/optimizing/metadata

## Dynamic Route

```react
export default function MovieDetail(props) {
  console.log(props);
  return <h1>Movie Detail</h1>;
}
// props를 찍어보면 백엔드에서 실행된다(터미널에 찍혀보임 브라우저 콘솔이 아니라)
// http://localhost:3000/movies/1?region=kr << url에서
// { params: { id: '1' }, searchParams: { region: 'kr' } } << 터미널에 이렇게 찍힘
